#!/usr/bin/env python3
import argparse
import json
import struct
import base64
from pathlib import Path
import hmac
import hashlib

def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate secure subscription contents.

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """
    # Load the json of the secrets file
    secrets_dict = json.loads(secrets)
    
    # Get master key and channel-specific key
    master_key = base64.b64decode(secrets_dict["master_key"])
    channel_keys = {int(k): base64.b64decode(v) for k, v in secrets_dict["channel_keys"].items()}
    mac_key = base64.b64decode(secrets_dict["mac_key"])
    
    # Fixed encoder ID for this example (should be read from configuration in a real system)
    encoder_id = 0x12345678
    
    # Validate channel
    if channel not in secrets_dict["channels"] and channel != 0:
        raise ValueError(f"Invalid channel {channel}")
    
    if channel == 0:
        raise ValueError("Cannot subscribe to emergency channel")
    
    # Generate HMAC for subscription validation (aligns with PDF section 1.2)
    # PDF shows: GenSubscription(T_fin, T_inicio, [CH_ID], DECODER_ID, ENCODER_ID)
    h = hmac.new(mac_key, digestmod=hashlib.sha256)
    
    # Include all fields in C_SUBS for HMAC calculation
    h.update(struct.pack("<I", channel))        # Channel ID
    h.update(struct.pack("<I", device_id))      # Decoder ID 
    h.update(struct.pack("<I", encoder_id))     # Encoder ID
    h.update(struct.pack("<Q", start))          # Start timestamp (T_inicio)
    h.update(struct.pack("<Q", end))            # End timestamp (T_fin)
    
    subscription_hmac = h.digest()
    
    # Create the subscription packet according to PDF format
    # Using the structure described in decoder.c: secure_subscription_update_packet_t
    subscription_packet = struct.pack("<IIQQQ", 
                                    channel,
                                    device_id, 
                                    start, 
                                    end,
                                    encoder_id)
    
    # Add the HMAC for integrity verification
    subscription_packet += subscription_hmac
    
    return subscription_packet

def parse_args():
    """Define and parse the command line arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()

def main():
    """Main function of gen_subscription"""
    # Parse the command line arguments
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    print(f"Wrote subscription to {str(args.subscription_file.absolute())}")

if __name__ == "__main__":
    main()