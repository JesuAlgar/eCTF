#!/usr/bin/env python3
import argparse
import json
import os
from pathlib import Path
<<<<<<< HEAD
from cryptography.hazmat.primitives import hashes, hmac
from cryptography.hazmat.backends import default_backend
import base64

def gen_secrets(channels: list[int]) -> bytes:
    """
    Genera un archivo de secretos seguro con claves específicas para canales y clave MAC.
    
    :param channels: Lista de números de canal que serán válidos en esta implementación.
    :returns: Contenido del archivo de secretos en formato JSON (bytes).
    """
    # Genera la master key (32 bytes para AES-256)
    master_key = os.urandom(32)
    
    # Deriva las claves específicas de cada canal usando HMAC-SHA256
    channel_keys = {}
    for channel in channels:
        h_obj = hmac.HMAC(master_key, hashes.SHA256(), backend=default_backend())
        h_obj.update(f"channel_{channel}".encode())
        channel_keys[channel] = h_obj.finalize()
    
    # Deriva la clave MAC
    h_obj = hmac.HMAC(master_key, hashes.SHA256(), backend=default_backend())
    h_obj.update(b"mac_key")
    mac_key = h_obj.finalize()
    
    # Crea el diccionario de secretos
=======
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import base64
import hmac
import hashlib

def gen_secrets(channels: list[int]) -> bytes:
    """
    Generate secure secrets file with channel-specific keys and MAC key
    
    :param channels: List of channel numbers that will be valid in this deployment
    :returns: Contents of the secrets file as bytes (JSON format)
    """
    # Generate master key (32 bytes for AES-256)
    master_key = os.urandom(32)
    
    # Derive channel-specific keys using HMAC-SHA256
    channel_keys = {}
    for channel in channels:
        h_obj = hmac.HMAC(master_key, digestmod=hashlib.sha256)
        h_obj.update(f"channel_{channel}".encode())
        channel_keys[channel] = h_obj.digest()  # Cambiado de finalize() a digest()
    
    # Derive MAC key
    h_obj = hmac.HMAC(master_key, digestmod=hashlib.sha256)
    h_obj.update(b"mac_key")
    mac_key = h_obj.digest()  # Cambiado de finalize() a digest()
    
    # Create secrets dictionary
>>>>>>> a10b08d2995248328ea156a9d864c38ae384ec8e
    secrets = {
        "master_key": base64.b64encode(master_key).decode(),
        "channels": channels,
        "channel_keys": {
            str(ch): base64.b64encode(key).decode() for ch, key in channel_keys.items()
        },
        "mac_key": base64.b64encode(mac_key).decode()
    }
    
    return json.dumps(secrets).encode()

def write_secrets_header(secrets: dict, header_path: Path):
    """
<<<<<<< HEAD
    Genera un archivo header en C con los secretos.
    Se crean definiciones para MASTER_KEY_BASE64, MAC_KEY_BASE64 y CHANNEL_KEY_1 hasta CHANNEL_KEY_8.
    Si algún canal no existe en los secretos, se define una clave dummy (32 bytes en cero, codificada en Base64).
    """
    def dummy_key():
        return base64.b64encode(b'\x00' * 32).decode()
=======
    Generate a C header file containing the secrets.
    The header defines the master key, MAC key and channel keys as constant arrays.
    """
    # Parse the secrets dictionary
    master_key_b64 = secrets.get("master_key", "")
    mac_key_b64 = secrets.get("mac_key", "")
    channel_keys = secrets.get("channel_keys", {})
>>>>>>> a10b08d2995248328ea156a9d864c38ae384ec8e
    
    lines = []
    lines.append("/* Autogenerated header from gen_secrets.py */")
    lines.append("#ifndef SECRETS_H")
    lines.append("#define SECRETS_H")
    lines.append("")
<<<<<<< HEAD
    lines.append('static const char MASTER_KEY_BASE64[] = "{}";'.format(secrets.get("master_key", "")))
    lines.append("")
    lines.append('static const char MAC_KEY_BASE64[] = "{}";'.format(secrets.get("mac_key", "")))
    lines.append("")
    # Se esperan definiciones para 8 claves de canal (canales 1 a 8)
    for ch in range(1, 9):
        key = secrets.get("channel_keys", {}).get(str(ch), dummy_key())
        lines.append('static const char CHANNEL_KEY_{}[] = "{}";'.format(ch, key))
    lines.append("")
=======
    # Store actual binary keys instead of base64 strings for direct use
    lines.append(f'static const uint8_t MASTER_KEY[32] = {{')
    master_key_bytes = base64.b64decode(master_key_b64)
    hex_values = [f"0x{b:02x}" for b in master_key_bytes]
    lines.append('    ' + ', '.join(hex_values))
    lines.append('};')
    lines.append("")
    
    lines.append(f'static const uint8_t MAC_KEY[32] = {{')
    mac_key_bytes = base64.b64decode(mac_key_b64)
    hex_values = [f"0x{b:02x}" for b in mac_key_bytes]
    lines.append('    ' + ', '.join(hex_values))
    lines.append('};')
    lines.append("")
    
    # Output channel keys as binary arrays
    for ch, key in sorted(channel_keys.items(), key=lambda x: int(x[0])):
        key_bytes = base64.b64decode(key)
        hex_values = [f"0x{b:02x}" for b in key_bytes]
        lines.append(f'static const uint8_t CHANNEL_KEY_{ch}[32] = {{')
        lines.append('    ' + ', '.join(hex_values))
        lines.append('};')
        lines.append("")
    
>>>>>>> a10b08d2995248328ea156a9d864c38ae384ec8e
    lines.append("#endif // SECRETS_H")
    
    with open(header_path, "w") as f:
        f.write("\n".join(lines))

def parse_args():
<<<<<<< HEAD
    parser = argparse.ArgumentParser()
    parser.add_argument("--force", "-f", action="store_true",
                        help="Forzar creación del archivo de secretos, sobrescribiendo el existente")
    parser.add_argument("--header", type=Path,
                        help="Ruta para el archivo header de salida (opcional)")
    parser.add_argument("secrets_file", type=Path,
                        help="Ruta al archivo de secretos a crear")
    parser.add_argument("channels", nargs="+", type=int,
                        help="Canales soportados. Nota: el canal 0 (broadcast) se considera siempre válido")
    return parser.parse_args()

def main():
=======
    """Define and parse the command line arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument("--force", "-f", action="store_true",
                        help="Force creation of secrets file, overwriting existing file")
    parser.add_argument("--header", type=Path,
                        help="Path to output header file (optional)")
    parser.add_argument("secrets_file", type=Path,
                        help="Path to the secrets file to be created")
    parser.add_argument("channels", nargs="+", type=int,
                        help="Supported channels. Channel 0 (broadcast) is always valid and will not be provided")
    return parser.parse_args()

def main():
    """Main function of gen_secrets"""
>>>>>>> a10b08d2995248328ea156a9d864c38ae384ec8e
    args = parse_args()
    secrets_bytes = gen_secrets(args.channels)
    secrets = json.loads(secrets_bytes.decode())
    
<<<<<<< HEAD
    # Escribe el archivo JSON de secretos
    with open(args.secrets_file, "wb" if args.force else "xb") as f:
        f.write(secrets_bytes)
    print(f"Se escribió el archivo de secretos en {str(args.secrets_file.absolute())}")
    
    # Si se solicita un header, se genera
    if args.header:
        write_secrets_header(secrets, args.header)
        print(f"Se escribió el header en {str(args.header.absolute())}")

if __name__ == "__main__":
    main()
=======
    # Write JSON file
    with open(args.secrets_file, "wb" if args.force else "xb") as f:
        f.write(secrets_bytes)
    print(f"Wrote secrets to {str(args.secrets_file.absolute())}")
    
    # If header output is requested, generate the header file
    if args.header:
        write_secrets_header(secrets, args.header)
        print(f"Wrote header to {str(args.header.absolute())}")

if __name__ == "__main__":
    main()
>>>>>>> a10b08d2995248328ea156a9d864c38ae384ec8e
